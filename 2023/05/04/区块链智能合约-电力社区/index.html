<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>区块链智能合约-电力社区</title><meta name="description" content="道阻且长，往事作序，来日为章。"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/blog/images/favicon.ico"><link rel="stylesheet" href="/blog/style/common/bulma.css"><link rel="stylesheet" href="/blog/style/base.css"><link rel="stylesheet" href="/blog/style/common/helper.css"><script src="/blog/js/common.js"></script><link rel="stylesheet" href="/blog/style/post.css"><link rel="stylesheet" href="/blog/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/blog/style/common/jquery.fancybox.min.css"><script src="/blog/js/highlight.pack.js"></script><meta name="description" content="Assignment1.Assignment guidance
Consider a smart community of electricity prosumers (electricity consumers who also produce electricity). There can be a mismatch between energy demand of a prosumer and the produced energy during a specific time interval. When a prosumer produces more energy than its requirement, it can sell it to the other prosumers of the.."><meta name="generator" content="Hexo 6.3.0"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/blog/">Jianhong Huang's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">区块链智能合约-电力社区</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/blog/">blog</a></h3><h3 class="is-inline-block"><a href="/blog/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/blog/">blog</a></h3><h3 class="is-inline-block"><a href="/blog/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Assignment"><span class="toc-text">Assignment</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Incentive-Mechanism"><span class="toc-text">Incentive Mechanism</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Code"><span class="toc-text">Code</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Table-of-system-behavior"><span class="toc-text">Table of system behavior</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Improvements"><span class="toc-text">Improvements</span></a></li></ol></div><div class="column is-9"><header class="my-4"></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">区块链智能合约-电力社区</h1><time class="has-text-grey" datetime="2023-05-04T21:57:41.000Z">2023-05-04</time><article class="mt-2 post-content"><h1 id="Assignment"><a href="#Assignment" class="headerlink" title="Assignment"></a><strong>Assignment</strong></h1><p>1.Assignment guidance</p>
<p>Consider a smart community of electricity prosumers (electricity consumers who also produce electricity). There can be a mismatch between energy demand of a prosumer and the produced energy during a specific time interval. When a prosumer produces more energy than its requirement, it can sell it to the other prosumers of the community who do not have enough energy to fulfill their need. Traditionally, a third party manages the trading of electricity between prosumers; however, a significant cost is paid to the third party for its services and the system is prone to security and privacy issues. To mitigate these challenges, a blockchain based energy trading mechanism emerged as a promising solution. In this coursework, you are required to design a smart contract for peer-to-peer (P2P) energy trading between electricity prosumers. </p>
<p><img src="image-20230504005644870.png" alt="image-20230504005644870"></p>
<p>Develop a main smart contract for energy trading for a local energy market where prosumers send requests for buying and selling energy. The smart contract should match the energy requests of buyers with sellers and trade the energy. In the smart contract, the prosumers must register before taking part in energy trading. When a new prosumer is registered on the network, a smart wallet for the prosumer is automatically created by the smart contract. To purchase the energy, a prosumer must have Ethers in his smart wallet (user can send ethers to smart contract). A registered prosumer should be able to send energy surplus (sell) or deficit (buy) request to the main smart contract: positive value for surplus energy and negative value for deficit energy.</p>
<p><img src="image-20230504005656779.png" alt="image-20230504005656779"></p>
<p>On getting the request, the main smart contract should check if the requester is buyer or seller and call the respective energy trading function of P2P smart contract (in case of buyer, main smart contract also checks if the buyer has sufficient balance in his smart wallet to purchase the required amount of energy, for instance, assume for 1 unit of energy, a buyer needs to pay 1 Ether). On getting the energy buying request, the P2P smart contract should first find the available energy seller in the market who has sufficient surplus energy to fulfill the energy requirement of the buyer. In case no seller is available, the buyer’s request should be added to the queue. Similarly, on getting the energy selling request, the P2P smart contract should first find the energy buyer in the market (queue) whose energy demand can be fulfilled by the seller; otherwise, the seller is added to the available seller’s queue. After energy trading, the information should be stored in the blockchain (records of both buyer and seller should be updated), and payment of energy should be added to the energy seller’s account (smart wallet). For each prosumer, its ID(address), energy status (how much energy it needs to buy or sell), and balance (Ethers in smart wallet) must be stored in the blockchain as a record and it must be updated after the prosumer takes part in energy trading. A prosumer should be able to withdraw his Ethers from smart wallet.</p>
<p><img src="image-20230504005717739.png" alt="image-20230504005717739"></p>
<p>Traditionally, the electricity prosumers prefer to store the surplus energy in the local energy storage system (ESS) instead of selling it to the buyers. They use this energy instead of buying energy from other sellers when they are in energy deficit. Propose (and implement in the smart contract) an incentive mechanism for the energy sellers and buyers to encourage them to take part in energy trading.</p>
<p>2.Assessment tasks</p>
<p>The following functions must be the part of the smart contracts. (The smart contracts are not limited to only these functions. You can add more functions as per requirement.)</p>
<p>P2P smart contract</p>
<p>(a) A structure to store information of prosumers. The information must include a prosumer’s ID (address), energy status (how much energy it needs to buy or sell), and balance (Ethers in smart wallet). You can also add more information as per requirements. Note that the data of buyers and sellers should not be stored separately, it should be stored in the same structure named “prosumer”. The data related to prosumers will only be stored in P2P smart contract. No more than one struct shall be used to store information.</p>
<p>(b) A function to register a new prosumer (add information of a new prosumer). Initially, only address of the user is added as its ID.</p>
<p>(c) Add functions to buy and sell energy.</p>
<p>Main smart contract</p>
<p>(a) Modifier function to make sure a prosumer is registered in the system before sending any request.</p>
<p>(b) Modifier function to ensure single registration of a prosumer (if an already registered prosumer request for the registration again, the function should send an error message saying the user is already registered).</p>
<p>(c) A modifier function to check whether a buyer has deposited sufficient funds (Ethers required to purchase the required amount of energy) to buy energy in the smart wallet.</p>
<p>(d) A public function to register a prosumer. A prosumer only calls this function to get registered (prosumer does not pass any value). The function checks (using the modifier function) the prior registration of the prosumers. If prosumer is already registered, the error message is generated (by the modifier function) to show that prosumer is already registered; otherwise the address of the new prosumer is sent to the P2P smart contract for storage (registration).</p>
<p>(e) A public function to enable a buyer to deposit some Ethers prior to energy buying request. The prosumer dose not pass any value to the function.</p>
<p>(f) A public function to accept prosumers’ requests and check if a prosumer has sent an energy selling or buying request and pass the data to the P2P smart contract. A prosumer passes positive value if he is a seller and negative value if he is a buyer. For example, if a buyer needs 3 units of energy, he will send -3 as input. The negative sign shows that the buyer needs the energy. On the contrary, if a seller wants to 3 units of energy, it will send 3 as an input. The positive 3 shows that the user has surplus energy to sell.</p>
<p>(g) A public function to check the current energy status of a seller or buyer (the amount of energy a buyer wants to buy or a seller</p>
<p>wants to sell). The function should not have any input arguments.</p>
<p>(h) A public function to check the balance of a prosumer. The function should not have any input arguments.</p>
<p>(i) A public function to withdraw the Ethers from smart wallets of prosumers. The function should not have any input arguments.(Note: funds can be withdrawn for a prosumer if his energy status is greater than or equal to zero, which means the prosumer does not need to buy energy at the moment.)</p>
<p><img src="image-20230504005812251.png" alt="image-20230504005812251"></p>
<p>Scenario to implement</p>
<p>Consider a scenario of a smart community with 20 electricity prosumers with unique addresses. All of the prosumers are registered on the blockchain. Suppose 10 prosumers are energy deficit and send the energy buying request to the smart contract. For each prosumer, randomly select energy deficit status (amount of required energy) between (1-6) units. On the other hand, 10 prosumers have surplus energy and choose their energy status (the amount of energy they want to sell) between (1-8) units. Send the requests of prosumers to the smart contract randomly and observe the behaviour of the system according to the instructions given above. Create a table and add the following information of all 20 prosumers in it:</p>
<p>(a) Address</p>
<p>(b) Initial energy status before energy trading</p>
<p>(c) Balance in the smart wallet before energy trading</p>
<p>(d) Energy status after energy trading</p>
<p>(e) Balance in smart wallet after energy trading</p>
<h1 id="Incentive-Mechanism"><a href="#Incentive-Mechanism" class="headerlink" title="Incentive Mechanism"></a><strong>Incentive Mechanism</strong></h1><p>I build communities where prosumers buy and sell energy.</p>
<p>In order to allow prosumers who have excess energy to sell their energy instead of hoarding it themselves. There needs to be an incentive for him&#x2F;her to sell his&#x2F;her energy.</p>
<p>First of all, let me explain that the normal price of each energy in our energy community is 1ether, that is, 10^18wei. At the same time, if the transaction is successful, both parties will be charged a 5% handling fee (assuming 5% is the market price, that is to say, other energy communities are charged as well).</p>
<p>In order to allow more users to participate in the community, I will first add a part of my own ether as an incentive pool.</p>
<p>The incentive mechanism is mainly divided into three parts:</p>
<p>First order incentive: No handling fee is required for the first transaction.</p>
<p>Follow-up incentives: Every time you successfully complete a transaction (excluding the first order), it means that your credit value is more secure, so transaction security risks are reduced. Therefore, every time you complete an order, you will be charged 0.1% less handling fee, with a maximum limit of 3%, that is, you will be charged a minimum of 2% handling fee.</p>
<p>Luck incentive: Each user will have a 1% probability of free handling fee(not the first order); and there will be 1% eth return for buyers, and 1% eth for sellers as rewards, and the upper limit is 1ether.</p>
<p>Note: Although no handling fee is charged for the first transaction, it is necessary to ensure that the balance in the account is sufficient to pay the handling fee. We promise and provide channels to return eth to your smart wallet, please feel free to use it!</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><pre><code class="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract P2P &#123;

    // a) a structure to sore information of prosumers
    struct Prosumer &#123;
        address pid; // address
        int energyStatus; // negative: amount of required energy; positive: the amount of energy they want to sell
        uint balance; // wei in smart wallet(10^18 wei = 1 ether)
        bool frozenBalance; // Funds are frozen if in progress
        bool completeFirstTrading; // Whether to complete the first transaction
        uint incentivePoints; // Credit(is the number of successful transactions after the non-first order)
    &#125;

    // Quickly get the prosumer through the address
    mapping (address =&gt; Prosumer) internal prosumers;

    // Scenario to implement: Suppose 10 prosumers are energy deficit, and other 10 prosumers have surplus energy
    bool internal odd = false;

    // seed for generating random numbers
    uint256 internal seed = 5423633257245624352373;

    // Store the address of the prosumer who wants to buy energy
    address[] internal buyQueue;

    // Store the address of the prosumer who wants to sell energy
    address[] internal saleQueue;

    // Incentive mechanism: the upper limit is exempt from 3% handling fee
    uint internal incentivePointThreshold = 30;

    // Incentive mechanism: the upper limit of cashback is 1 ether
    uint internal cashBackThreshold = 10**18;

    // Incentive mechanism: normal handling fee is 5%
    uint internal perOfDandlingFee = 50;

    // Energy and Balance Modified Log
    event printTradingLog(string message, address buyer, address seller, int energyNum, uint balanceNum);
    // luck: Whether the luck incentive is activated;
    // incentiveCashBack: cashback amount; 
    // handlingFee: handling fee;
    event printOtherFeeLog(string message, address addr, bool luck, uint incentiveCashBack, uint handlingFee);
    // Logs of users in the queue
    event printQueueLog(string queueName, address addr);

    // b) register a new prosumer
    function register(address addr) external &#123;
        prosumers[addr] = Prosumer(
            &#123;
                pid: addr,
                energyStatus: odd == true ? random(1, 6, false) : random(1, 8, true),
                balance: 0,
                frozenBalance: false,
                completeFirstTrading: false,
                incentivePoints: 0
            &#125;
        );

        odd = !odd;
    &#125;

    // c) buy and sell energy(Contains multiple functions to complete)
    function trading(address buyer, address seller, int energyNum) internal &#123;
        uint balanceChange = uint(energyNum * (10**18));
        // handling energy
        emit printTradingLog(&quot;energy status and balance start changing&quot;, buyer, seller, energyNum, balanceChange);
        modifyEnergyStatus(buyer, energyNum);
        modifyEnergyStatus(seller, -energyNum);

        // handling balance
        decBalance(buyer, balanceChange);
        incBalance(seller, balanceChange);
        emit printTradingLog(&quot;energy status and balance finish changing&quot;, buyer, seller, energyNum, balanceChange);
        
        // handling other fee
        if(getCompleteFirstTrading(buyer)) &#123;
            otherFee(buyer, energyNum);
        &#125;
        if(getCompleteFirstTrading(seller)) &#123;
            otherFee(seller, energyNum);
        &#125;
    &#125;

    // Match buyers and sellers
    function matchRequest() external returns(int, int) &#123;

        // Index of marked completed transactions
        int markBuyIndex = -1;
        int markSaleIndex = -1;
        for(uint i = 0; i &lt; buyQueue.length; i++) &#123;
            Prosumer storage buyer = prosumers[buyQueue[i]];
            for(uint j = 0; j &lt; saleQueue.length; j++) &#123;
                Prosumer storage seller = prosumers[saleQueue[j]];
                // Seller can fully meet the need of buyer
                if(seller.energyStatus &gt;= -buyer.energyStatus) &#123;
                    int transferEnergy = -buyer.energyStatus;
                    // Transactions dealing with energy and balance
                    trading(buyQueue[i], saleQueue[j], transferEnergy);

                    if(seller.energyStatus == 0) &#123;
                        // If the energy of the seller is 0, mark it
                        markSaleIndex = int(j);
                        // Transaction completed, unfreeze
                        setFrozenBalanceOfProsumer(saleQueue[j], false);
                        setCompleteFirstTrading(saleQueue[j], true);
                    &#125;

                    // mark buyer
                    markBuyIndex = int(i);
                    // Transaction completed, unfreeze
                    setFrozenBalanceOfProsumer(buyQueue[i], false);
                    // Transaction completed, set to true
                    setCompleteFirstTrading(buyQueue[i], true);
                    break;
                // Seller can&#39;t fully meet the need of buyer
                &#125; else &#123;
                    int transferEnergy = seller.energyStatus;
                    // Transactions dealing with energy and balance
                    trading(buyQueue[i], saleQueue[j], transferEnergy);

                    // mark seller
                    markSaleIndex = int(j);
                    // Transaction completed, unfreeze
                    setFrozenBalanceOfProsumer(saleQueue[j], false);
                    // Transaction completed, set to true
                    setCompleteFirstTrading(saleQueue[j], true);
                &#125;
            &#125;
        &#125;

        return (markBuyIndex, markSaleIndex);
    &#125;

    // Remove the completed matching requests from the queue
    function adjustQueue(int buyerIndex, int sellerIndex) external &#123;
        
        // If it is -1, it means that remove is not required
        if(buyerIndex != -1) &#123;
            uint bIndex = uint(buyerIndex);
            for(uint x = bIndex + 1; x &lt; buyQueue.length; x++) &#123;
                // The original location needs to be freed first, otherwise it will occupy memory
                delete buyQueue[x - bIndex - 1];
                buyQueue[x - bIndex - 1] = buyQueue[x];
            &#125;
            for(uint x = bIndex; x &gt;= 0; x --) &#123;
                buyQueue.pop();
                // uint will not be less than 0, so special judgment is required
                if(x == 0) &#123;
                    break;
                &#125;
            &#125;
        &#125;

        if(sellerIndex != -1) &#123;
            uint sIndex = uint(sellerIndex);
            for(uint y = sIndex + 1; y &lt; saleQueue.length; y++) &#123;
                delete saleQueue[y - sIndex - 1];
                saleQueue[y - sIndex - 1] = saleQueue[y];
            &#125;
            for(uint y = sIndex; y &gt;= 0; y --) &#123;
                saleQueue.pop();
                if(y == 0) &#123;
                    break;
                &#125;
            &#125;
        &#125;
    &#125;

    // modify energy status
    function modifyEnergyStatus(address addr, int energyNum) internal &#123;
        prosumers[addr].energyStatus += energyNum;
    &#125;
    
    // increase balance
    function incBalance(address addr, uint amount) internal &#123;
        prosumers[addr].balance += amount;
    &#125;

    // decrease balance
    function decBalance(address addr, uint amount) internal &#123;
        prosumers[addr].balance -= amount;
    &#125;

    // Calculate the rebate amount and cannot exceed the maximum value
    function calculateTheCashBackAmount(uint val) internal view returns (uint) &#123;
        return cashBackThreshold &gt;= val ? val : cashBackThreshold;
    &#125;

    // Whether to trigger the luck incentive mechanism
    function luckIncentive() internal view returns (bool) &#123;
        return random(1, 100, true) == 1 ? true : false;
    &#125;

    // Calculate handling fees
    function getHandlingFee(address addr, int energyNum) public view returns (uint) &#123;
        return uint(uint(energyNum) * (perOfDandlingFee - prosumers[addr].incentivePoints) * (10**15));//10^18/1000
    &#125;

    // Settlement of all fees except for normal energy transaction payments
    function otherFee(address addr, int energyNum) internal &#123;
        
        if(luckIncentive()) &#123;
            uint incentiveCashBack = calculateTheCashBackAmount(uint(energyNum) * (10**16));//10^18/100
            incBalance(addr, incentiveCashBack);
            emit printOtherFeeLog(&quot;otherFee&quot;, addr, true, incentiveCashBack, 0);
        &#125; else &#123;
            uint handlingFee = getHandlingFee(addr, energyNum);
            decBalance(addr, handlingFee);
            emit printOtherFeeLog(&quot;otherFee&quot;, addr, false, 0, handlingFee);
        &#125;

        incIncentivePointsOfProsumer(addr);
    &#125;

    // Add to the buyer or seller queue based on Boolean values
    function queuing(address addr, bool buyerQueue) external &#123;
        if(buyerQueue) &#123;
            buyQueue.push(addr);
            emit printQueueLog(&quot;buyer&quot;, addr);
        &#125; else &#123;
            saleQueue.push(addr);
            emit printQueueLog(&quot;seller&quot;, addr);
        &#125;
        setFrozenBalanceOfProsumer(addr, true);
    &#125;

    // get set
    function getCompleteFirstTrading(address addr) internal view returns (bool) &#123;
        return getProsumer(addr).completeFirstTrading;
    &#125;

    function setCompleteFirstTrading(address addr, bool flag) internal view &#123;
        getProsumer(addr).completeFirstTrading = flag;
    &#125;

    // get set
    function getFrozenBalanceOfProsumer(address addr) external view returns (bool) &#123;
        return getProsumer(addr).frozenBalance;
    &#125;

    function setFrozenBalanceOfProsumer(address addr, bool state) internal &#123;
        prosumers[addr].frozenBalance = state;
    &#125;
    
    // get
    function getProsumer(address addr) internal view returns(Prosumer memory) &#123;
        return prosumers[addr];
    &#125;

    function getEnergyStatusOfProsumer(address addr) external view returns (int) &#123;
        return getProsumer(addr).energyStatus;
    &#125;

    function getBalanceOfProsumer(address addr) external view returns (uint) &#123;
        return getProsumer(addr).balance;
    &#125;

    // get inc
    function getIncentivePointsOfProsumer(address addr) external view returns (uint) &#123;
        return getProsumer(addr).incentivePoints;
    &#125;

    function incIncentivePointsOfProsumer(address addr) internal &#123;
        if(incentivePointThreshold &gt; prosumers[addr].incentivePoints) &#123;
            prosumers[addr].incentivePoints += 1;
        &#125;
        
    &#125;

    // modify balance by wei(10^18wei=1ether)
    function incBalanceByEth(address addr, uint256 value) public payable &#123;
        prosumers[addr].balance += value;
    &#125;

    function decBalanceByEth(address addr, uint256 amount) public &#123;
        prosumers[addr].balance -= amount;
    &#125;
    
    function regitered(address addr) external view returns(bool) &#123;
        if(prosumers[addr].pid == address(0x0)) &#123;
            // The Prosumer object corresponding to this address has not been created yet
            return false;
        &#125; else &#123;
            return true;
        &#125;
    &#125;

    // Generate random numbers according to the interval, and you can specify whether they are negative or positive
    function random(uint256 from, uint256 to, bool positive) internal view returns (int256) &#123;
        require(from &lt; to, &quot;The interval size should be a positive number!&quot;);

        uint256 randomNumber = uint256(keccak256(abi.encodePacked(seed, block.timestamp)));

        uint256 range = to - from + 1;
        int256 randomRangeNumber = int256((randomNumber % range) + from);
        
        return positive == true ? randomRangeNumber : -randomRangeNumber;
    &#125;
&#125;

contract ElecCommunity &#123;

    // main smart contract interacts with p2p smart contract.
    P2P internal p2p;

    // Create p2p first, and then pass in the contract address
    constructor(address addr) &#123;
        p2p = P2P(addr);
    &#125;

    // function call log
    event printCallingFuncLog(string contractName, string funcCalling, address sender);
    // ether change log
    event printEtherChangeLog(address sender, string operation, uint amount);

    // a) make sure a prosumer is registered
    modifier haveRegistered &#123;
        require(p2p.regitered(msg.sender), &quot;Need to register first!&quot;);
        
        _;
    &#125;

    // b) ensure single registration of a prosumer
    modifier unregistered &#123;
        require(!p2p.regitered(msg.sender), &quot;Already registered!&quot;);
        
        _;
    &#125;

    // c) check whether a buyer has deposited sufficient funds
    modifier checkBuyerDeposit(address addr) &#123;
        require(p2p.getBalanceOfProsumer(addr) &gt;= uint(-p2p.getEnergyStatusOfProsumer(addr) * 10**18) + p2p.getHandlingFee(addr, -p2p.getEnergyStatusOfProsumer(addr)), &quot;Balance isn&#39;t enough to purchase energy!&quot;);

        _;
    &#125;

    // d) register a prosumer
    function register() public unregistered &#123;
        emit printCallingFuncLog(&quot;ElecCommunity&quot;, &quot;start calling function register&quot;, msg.sender);
        p2p.register(msg.sender);
        emit printCallingFuncLog(&quot;ElecCommunity&quot;, &quot;finish calling function register&quot;, msg.sender);
    &#125;

    // e) deposit some ethers
    function addEthers() public payable haveRegistered &#123;  
        emit printEtherChangeLog(msg.sender, &quot;begin adding&quot;, msg.value);
        p2p.incBalanceByEth(msg.sender, msg.value);
        emit printEtherChangeLog(msg.sender, &quot;end adding&quot;, msg.value);
    &#125;

    // f) accept prosumers&#39; requests
    function tradingRequest() public haveRegistered &#123;
        emit printCallingFuncLog(&quot;ElecCommunity&quot;, &quot;start calling function tradingRequest&quot;, msg.sender);
        // join the queue
        addQueue(msg.sender);
        // matching
        (int buyerIndex, int sellerIndex) = p2p.matchRequest();
        // Remove users from queue who have completed transactions
        p2p.adjustQueue(buyerIndex, sellerIndex);

        emit printCallingFuncLog(&quot;ElecCommunity&quot;, &quot;finish calling function tradingRequest&quot;, msg.sender);
    &#125;

    // g) check the current energy status of a seller of buyer
    function isBuyer(address addr) internal view returns (bool) &#123;
        return p2p.getEnergyStatusOfProsumer(addr) &gt; 0 ? false : true;
    &#125;

    // h) check balance of a prosumer
    function checkBlanceBefWithdraw(address addr, uint256 amount) internal view returns (bool) &#123;
        return p2p.getBalanceOfProsumer(addr) &gt;= amount ? true : false;
    &#125;

    // i) withdraw the wei(10^18=1eth) from smart wallets of prosumers
    function withdrawEthers(uint256 amount) public haveRegistered needActiveState(msg.sender) &#123;
        require(checkBlanceBefWithdraw(msg.sender, amount), &quot;Not enough balance!&quot;);
        emit printEtherChangeLog(msg.sender, &quot;begin withdrawing&quot;, amount);
        p2p.decBalanceByEth(msg.sender, amount);
        payable(msg.sender).transfer(amount);
        emit printEtherChangeLog(msg.sender, &quot;end withdrawing&quot;, amount);
    &#125;

    // Prevent funds from being withdrawn when trading
    modifier needActiveState(address addr) &#123;
        require(!p2p.getFrozenBalanceOfProsumer(addr), &quot;You can do this operation after trading!&quot;);

        _;
    &#125;

    // join buyer queue
    function addBuyerQueue(address addr) internal checkBuyerDeposit(addr) &#123;
        p2p.queuing(addr, true);
    &#125;

    // join seller queue
    function addSellerQueue(address addr) internal checkSellerDeposit(addr) &#123;
        p2p.queuing(addr, false);
    &#125;

    // check seller&#39;s deposit
    modifier checkSellerDeposit(address addr) &#123;
        require(p2p.getBalanceOfProsumer(addr) &gt;= p2p.getHandlingFee(addr, p2p.getEnergyStatusOfProsumer(addr)), &quot;Balance isn&#39;t enough to pay handling fee!&quot;);

        _;
    &#125;

    // judge and join queue
    function addQueue(address addr) internal needActiveState(addr) &#123;
        bool buyerFlag = isBuyer(addr);
        buyerFlag == true ? addBuyerQueue(addr) : addSellerQueue(addr);
    &#125;
&#125;
</code></pre>
<h1 id="Table-of-system-behavior"><a href="#Table-of-system-behavior" class="headerlink" title="Table of system behavior"></a><strong>Table of system behavior</strong></h1><table>
<thead>
<tr>
<th>Address</th>
<th>Energy(before)</th>
<th>Balance(before)</th>
<th>Energy(after)</th>
<th>Balance(after)</th>
</tr>
</thead>
<tbody><tr>
<td>0x5B38Da6a701c568545dCfcB03FcB875f56beddC4</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2</td>
<td>-4</td>
<td>6</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db</td>
<td>6</td>
<td>2</td>
<td>0</td>
<td>8</td>
</tr>
<tr>
<td>0x78731D3Ca6b7E34aC0F824c42a7cC18A495cabaB</td>
<td>-6</td>
<td>7</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0x617F2E2fD72FD9D5503197092aC168c91465E7f2</td>
<td>3</td>
<td>2</td>
<td>0</td>
<td>5</td>
</tr>
<tr>
<td>0x17F6AD8Ef982297579C203069C1DbfFE4348c372</td>
<td>-5</td>
<td>8</td>
<td>0</td>
<td>3</td>
</tr>
<tr>
<td>0x5c6B0f7Bf3E7ce046039Bd8FABdfD3f9F5021678</td>
<td>5</td>
<td>3</td>
<td>0</td>
<td>8</td>
</tr>
<tr>
<td>0x03C6FcED478cBbC9a4FAB34eF9f40767739D1Ff7</td>
<td>-3</td>
<td>9</td>
<td>0</td>
<td>6</td>
</tr>
<tr>
<td>0x1aE0EA34a72D944a8C7603FfB3eC30a6669E454C</td>
<td>7</td>
<td>1</td>
<td>0</td>
<td>8</td>
</tr>
<tr>
<td>0x0A098Eda01Ce92ff4A4CCb7A4fFFb5A43EBC70DC</td>
<td>-5</td>
<td>6</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c</td>
<td>3</td>
<td>4</td>
<td>0</td>
<td>7</td>
</tr>
<tr>
<td>0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C</td>
<td>-5</td>
<td>7</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>0x4B0897b0513fdC7C541B6d9D7E929C4e5364D2dB</td>
<td>7</td>
<td>2</td>
<td>0</td>
<td>9</td>
</tr>
<tr>
<td>0x583031D1113aD414F02576BD6afaBfb302140225</td>
<td>-3</td>
<td>6</td>
<td>0</td>
<td>3</td>
</tr>
<tr>
<td>0xdD870fA1b7C4700F2BD7f44238821C26f7392148</td>
<td>4</td>
<td>1</td>
<td>0</td>
<td>5</td>
</tr>
<tr>
<td>0xFedA05F598803923A2Dd114483E57a1C423353E5</td>
<td>-5</td>
<td>6</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0x2651d6bE063936368022c7C54608716e2d843333</td>
<td>3</td>
<td>2</td>
<td>0</td>
<td>5</td>
</tr>
<tr>
<td>0xA1D603FD36eA19d374774c0bD81c88B5Dd07C6af</td>
<td>-4</td>
<td>8</td>
<td>0</td>
<td>4</td>
</tr>
<tr>
<td>0x49a04437F0154F02536fF7000fB4bcf679487DA6</td>
<td>7</td>
<td>4</td>
<td>0</td>
<td>11</td>
</tr>
<tr>
<td>0x6A47F9a7b058EBbee1F8B8F42766F5A4d66aE1Fd</td>
<td>-6</td>
<td>9</td>
<td>0</td>
<td>3</td>
</tr>
</tbody></table>
<p>Note: In fact, when I first got this result, I felt a bit unexpected, but after checking and calculating, there is indeed no problem. The energy of buyers and sellers in this experiment just offset (The absolute value of both sides is 46).</p>
<h1 id="Improvements"><a href="#Improvements" class="headerlink" title="Improvements"></a><strong>Improvements</strong></h1><p>In fact, I didn’t add too many new features to smart contract, most of the features not mentioned in the documentation are authored for the incentive mechanism, which has already been explained in the first point. In addition, there are some new functions, such as random functions, which are used to generate random values, and some getter and setter functions are used to obtain the information of fields in prosumer, and I also added some event functions to the smart contract to print and track logs. Finally, each of my functions has comments for easy understanding.</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/blog/2023/04/06/%E6%97%A0%E5%90%91%E5%9B%BE%E6%B1%82%E8%A7%A3%E7%94%9F%E6%88%90%E6%A0%91%E4%B8%AA%E6%95%B0/" title="无向图求解生成树个数"><span class="has-text-weight-semibold">Next: 无向图求解生成树个数</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/SauerkrautFFish"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> Jianhong Huang 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/blog/js/jquery-3.6.1.min.js"></script><script src="/blog/js/jquery-fancybox.min.js"></script><script src="/blog/js/img_zoom.js"></script><script src="/blog/js/post.js"></script></body></html>