<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>商业和开源的faas伸缩性比较</title><meta name="description" content="道阻且长，往事作序，来日为章。"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/blog/images/favicon.ico"><link rel="stylesheet" href="/blog/style/common/bulma.css"><link rel="stylesheet" href="/blog/style/base.css"><link rel="stylesheet" href="/blog/style/common/helper.css"><script src="/blog/js/common.js"></script><link rel="stylesheet" href="/blog/style/post.css"><link rel="stylesheet" href="/blog/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/blog/style/common/jquery.fancybox.min.css"><script src="/blog/js/highlight.pack.js"></script><meta name="description" content="Problem motivation最近faas越来越火，将来或许会成为主流，因为faas让开发者更关注于代码开发，不用负责服务器的管理，并且易于拓展和伸缩。为了与时俱进，跟上时代洪流，我想要调查并研究已经存在的faas实现方案，并对它的伸缩性等性能做测试、分析和总结。
Related work调查发现Faas有商用的平台的和开源的方案，因此我觉得在商用和开源各选择一个比较有代表性的faas作品来做测试、分析。
市面上目前faas商用做的比较好的有Aws lambda，google cloud funtions，azure functions，开源做的比较好的是openfaas，因此商用我选用azure functions，开源选择openfaas的。
我们准备调查研究商业用的azure faas和开源的o.."><meta name="generator" content="Hexo 6.3.0"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/blog/">Jianhong Huang's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">商业和开源的faas伸缩性比较</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/blog/">blog</a></h3><h3 class="is-inline-block"><a href="/blog/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/blog/">blog</a></h3><h3 class="is-inline-block"><a href="/blog/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Problem-motivation"><span class="toc-text">Problem motivation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Related-work"><span class="toc-text">Related work</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%95%86%E7%94%A8faas%EF%BC%88azure-functions%EF%BC%89%E7%9A%84%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C"><span class="toc-text">商用faas（azure functions）的相关工作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Openfaas%E7%9A%84%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C"><span class="toc-text">Openfaas的相关工作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Experimental-design"><span class="toc-text">Experimental design</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E6%B5%8B%E8%AF%95cpu"><span class="toc-text">对于测试cpu</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E6%B5%8B%E8%AF%95%E5%86%85%E5%AD%98"><span class="toc-text">对于测试内存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Implementation"><span class="toc-text">Implementation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Azure-function"><span class="toc-text">Azure function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Openfaas"><span class="toc-text">Openfaas</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Results"><span class="toc-text">Results</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Quality-of-evaluation"><span class="toc-text">Quality of evaluation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cpu"><span class="toc-text">cpu</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Memory"><span class="toc-text">Memory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-x2F-scripts"><span class="toc-text">Code&#x2F;scripts</span></a></li></ol></div><div class="column is-9"><header class="my-4"></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">商业和开源的faas伸缩性比较</h1><time class="has-text-grey" datetime="2023-04-03T20:32:32.000Z">2023-04-03</time><article class="mt-2 post-content"><h2 id="Problem-motivation"><a href="#Problem-motivation" class="headerlink" title="Problem motivation"></a><strong>Problem motivation</strong></h2><p>最近faas越来越火，将来或许会成为主流，因为faas让开发者更关注于代码开发，不用负责服务器的管理，并且易于拓展和伸缩。为了与时俱进，跟上时代洪流，我想要调查并研究已经存在的faas实现方案，并对它的伸缩性等性能做测试、分析和总结。</p>
<h2 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a><strong>Related work</strong></h2><p>调查发现Faas有商用的平台的和开源的方案，因此我觉得在商用和开源各选择一个比较有代表性的faas作品来做测试、分析。</p>
<p>市面上目前faas商用做的比较好的有Aws lambda，google cloud funtions，azure functions，开源做的比较好的是openfaas，因此商用我选用azure functions，开源选择openfaas的。</p>
<p>我们准备调查研究商业用的azure faas和开源的openfaas在性能，伸缩性等有什么区别。</p>
<h4 id="商用faas（azure-functions）的相关工作"><a href="#商用faas（azure-functions）的相关工作" class="headerlink" title="商用faas（azure functions）的相关工作"></a>商用faas（azure functions）的相关工作</h4><p>登录azure，使用了学校的订阅，并使用了学校分配的资源组，创建了funtion，选择的语言是python，为了方便开发和测试，我可以使用两种方式连接和部署azure function。第一种：本地下载visual studio code，通过拓展库的azure function连接azure，然后编写python函数代码；第二种是直接通过azure提供的平台去编写python代码。</p>
<h4 id="Openfaas的相关工作"><a href="#Openfaas的相关工作" class="headerlink" title="Openfaas的相关工作"></a>Openfaas的相关工作</h4><p>在azure创建一个k8s服务，研究如何部署openfaas，并对外暴露端口，如何远程拉取docker hub的镜像，如何使用metrics server对流量监控，实现自动伸缩的能力，对docker，k8s等命令和原理做了解，研究如何使用faas-cli。</p>
<h2 id="Experimental-design"><a href="#Experimental-design" class="headerlink" title="Experimental design"></a><strong>Experimental design</strong></h2><p>本次实验主要是对商用的faas（选用azure function）和开源的openfaas做性能测试（主要是对伸缩性做测试），实验会测试两个方面，一个是测试cpu的伸缩性；第二个是测试内存的伸缩性。</p>
<h4 id="对于测试cpu"><a href="#对于测试cpu" class="headerlink" title="对于测试cpu"></a>对于测试cpu</h4><p>我会选择做nxn的矩阵乘法，并且n会固定传1000，矩阵随机生成，每个请求耗时都在500-600毫秒之间，我会通过jmeter开启多线程在1200秒内一共会有24000个线程一起请求对应的function地址；因为是在大流量的情况下，可能会出现响应失败的情况，这个时候我会着重观察是否在一段时间后可以恢复响应；如果成功返回，那么我会在返回的主体中，返回当前主机的mac地址，以便让我知道faas是否做了自动伸缩，以保证它的稳定性，可用性。</p>
<h4 id="对于测试内存"><a href="#对于测试内存" class="headerlink" title="对于测试内存"></a>对于测试内存</h4><p>我会选择写文件，通过开启jmeter多线程并发访问对应的function，function做的主要工作是，使用io流对文件进行写入，字符的数量是20000000，和测试cpu时的类似，字符串长度和字符串本身的字符都是随机生成的，但是为了避免大批量的写文件导致文件过度堆积或者避免手动删除的负担，我会选择写入&#x2F;tmp里，因为linux对这块区域使用了定时清理，所以让我更放心的去测试，同时我也会观察是否正常响应，如果正常响应我也还是会打印出它的mac地址，已确认是否扩容，扩容的量是多少；如果没有正常返回，我还是会继续多线程访问，直到它扩容到足够能成功响应的时候，并记录它的时间。</p>
<p>共同的部分：</p>
<p>为了保证函数的健壮性，需要对可能异常的代码块做好try except防止程序异常导致崩溃。对于程序的出入口，出现异常跳转的代码块都要做好日志埋点，方便跟踪整个链路，以便还原发生的事件。</p>
<p>为了测试伸缩性，我会使用apache的Jmeter，通过设置线程组，http请求来并发的发送请求，通过增加监听器：观察树，聚合报告，响应图来检验和分析整个过程，最终得出结论。</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a><strong>Implementation</strong></h2><h4 id="Azure-function"><a href="#Azure-function" class="headerlink" title="Azure function"></a>Azure function</h4><p>我们通过vs code安装azure function的拓展插件，通过跳转网页登录后，选择function，并在本地构造一个工作区后，可以开始编写function了，按照上述说的，我主要选择两种方式测试它的性能（主要是伸缩性），第一是cpu密集型的任务，第二是对内存和磁盘io的。cpu密集型任务我编写的两个1000x1000矩阵相乘，计算任务做完后，我会返回当前机器的mac地址，以便让我确认是否有扩容的操作，并且整体时间我控制在500-600毫秒返回，当大并发的情况下，它不得不扩容才能成功的返回响应。对于内存和磁盘io做伸缩性测试，主要是做写文件的操作，因为磁盘非常大，挺难做扩容的，所以主要还是对内存做压力测试，看看是否有扩容操作，python有一个库专门是针对每个系统的临时存储区做一些io操作的，这个库名是tempfile，通过tempfile我们就不用手动定位临时文件区的位置，直接通过这个库就能实现，我固定往里面写入20000000个字符串，相信20000000字符串就算存入内存中也是一笔开销，并且我还通过并发去请求，几千几万流量打进来，内存再大肯定也顶不住，得做扩容才行。通过vs code很容易就把代码上传到azure function即可调用测试，非常方便。</p>
<h4 id="Openfaas"><a href="#Openfaas" class="headerlink" title="Openfaas"></a>Openfaas</h4><p>要部署openfaas就比azure function要困难和麻烦的多了，首先我们需要借助k8s的能力，在azure建立了一个k8s服务，并且选择自动扩容（这是很关键的一步），我选择的最小节点池大小为1，最大为105，通过azure本地的shell登录进了k8s机器里，通过helm下载了openfaas服务，并且通过kubectl命令部署了openfaas，并且对外提供访问的能力，接下来我们下载faas-cli，这个是openfaas的客户端，我们可以把代码通过faas-cli去和openfaas做交互并部署函数。通过faas-cli新创建一个函数，faas-cli会帮我们生成好handler.py, yaml文件，requirements.txt文件等，然后通过faas-cli build构建好整个环境，faas-cli push把function打包成镜像上传到docker hub上保存，然后可以通过faas-cli deploy把上传到docker hub上的镜像拉下来部署，并且会返回部署成功的ip地址和端口号。比较方便的一点是k8s自带了metrics server，所以流量监控这块已经做好准备，我们只需要设置触发扩容的阈值就可以了，通过kubectl hpa可以设置对外暴露服务的扩容阈值，并且最大和最小节点数都会打印出来。代码和azure function所部署的类似，所以就不做再次说明了，不同的可能是返回体，因为azure在python上有自己的库，也有自己的返回类型，而在openfaas我可能只是简单的返回str类型。</p>
<p>并且不管是openfaas还是azure function我都做好了日志输出，在函数被调用的时候，出现异常的时候，正常返回的时候，都做了日志埋点，方便跟踪整个链路。</p>
<h2 id="Results"><a href="#Results" class="headerlink" title="Results"></a><strong>Results</strong></h2><p>[贴图]（感兴趣的可以通过邮箱向我要源码和过程截图）</p>
<h2 id="Quality-of-evaluation"><a href="#Quality-of-evaluation" class="headerlink" title="Quality of evaluation"></a><strong>Quality of evaluation</strong></h2><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Azure function和openfaas都是用于构建无服务的工具，本实验其实有非常多的局限性，所以只能做参考。因为尽管openfaas和azure function都有着伸缩性，可以根据当前请求量等做自动缩放，但是azure functions毕竟是一个完全托管的服务，并且有着强大的azure平台支撑，是按照流量计算消费，所以伸缩性在理论上可以理解成无限大。但是我们的openfaas需要借助k8s的自动扩缩容能力，通过metrics server收集cpu使用率和内存使用率也可以做到自动缩放（根据需要增加或减少资源），如果只是瞬间的高并发，可能就不会实现扩容，并且扩容需要一定的时间，在这段时间里，如果生产者远远慢于消费者，那么还是会出现服务不响应的问题。所以对于openfaas的测试我会在一段时间内持续的访问，以便看到它扩容的过程。</p>
<h4 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h4><p>对于openfaas的cpu伸缩性测试来说，我们可以发现，在没有通过网络访问之前，cpu的指标维持在比较低的一个水平，在我们开始启动多线程，不断的进行加压访问后（比如一秒启动10个线程），马上就开始出现崩溃的情况，频繁的出现socket连接问题，k8s过了一段时间才逐渐反应过来，我们可以从图片中看到，k8s在控制节点池的增加，pod也在开始不断的扩容。过了一段时间后（大约4分钟），k8s已经扩容到了足够接纳我访问的地步，渐渐的能响应我的访问，我们可以看到cpu一开始维持在比较高的水平，在扩容节点后，节点池中的每一个节点都承受了一部分访问压力，做到了负载均衡，同时我们可以看到响应时间一开始非常高，后面就在某个区间来回波动了。并且在我断开jmeter的压力测试，节点池和pods根据当前cpu的情况都在不断的缩容，最终缩到一个节点池和一个pod。</p>
<p>而azure function令我比较惊讶的是，对于同一个function它一开始承受的压力远远比我对openfaas施加的压力大2倍，但一开始也没有报错，通过图片可以看出来，所有的http请求都得到正面的回应，并且我们看到返回的mac地址，都是不同的主机做的返回，也就是说azure function的扩容能力非常强大，同时我也尝试了过了半个小时后使用一个线程不断的同步访问，发现都是返回的同一个mac地址，所以azure function一开始就只部署在了一台主机上，并且在一开始就做到了应对如此大的流量，并且它的扩容时间非常的短暂，非常的令我惊讶，同时我们可以发现响应时间图一直在某个区间波动，比较的平稳。</p>
<h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h4><p>对于openfaas的内存伸缩性测试，我们可以看到，在访问之前，我们先部署到了k8s上，并且在jmeter创建好脚本，准备做并发访问，当前的内存使用率维持在35%左右，随后我们开始做并发压力访问，很快的出现了测试cpu伸缩性时候出现的问题，刚开始或许能成功的做一些返回，但是随后随机流量的加大，很快就出现了请求失败的问题，一方面是因为访问一次所需要的时间的确比较久，大概1-2s才能返回，第二个是因为它的扩容需要时间，我们能发现过了一端时间后，大概5分钟，他就能承受住我们的流量，访问后开始逐步的能返回结果了，我们可以看到内存值在不断的波动，并且达到设置的阈值后，不断的扩容节点池和pods，使得每个pod都维持在阈值以下，并且时间响应图能看出来，响应时间在某个时间达到了高峰，后面就下降到一个区域，维持成了一条平稳的直线。在关闭了脚本，关闭了多线程后，我们发现节点池在变少，pods也在不断缩容。</p>
<p>Azure function的内存伸缩性测试和cpu伸缩性测试一样，让人非常的赞叹，持续的正常响应，它的毫秒级内存波动也是挺大的，时间响应在一开始达到了巅峰，但是在短短20秒内做到了快速的下降，并且维持一条直线，实在是令我惊讶不已。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总的来说，azure function有着强大的平台做支撑，伸缩能力强，扩容时间短，文档全面，并且有实时的技术支持，各方面都做到比较完善，但是毕竟是商用，所以收费是需要的。</p>
<p>Openfaas也有着自己的社区和全面的文档，但是在技术实现上，可能需要借助k8s或者使用openfaas pro实现自动伸缩的能力，并且扩容缩容的时间还需要配置好，以免出现流量过大导致扩容不及时，更好的做法可能是在一开始就部署一部分的节点，以应对一开始的大流量。同时openfaas是开源的，所以如果想要寻求帮助，解决可能没有azure专人解答高效。但毕竟是开源的，在大家的努力下，将来或许会成为一款性能顶级的faas实现方案。</p>
<h2 id="Code-x2F-scripts"><a href="#Code-x2F-scripts" class="headerlink" title="Code&#x2F;scripts"></a><strong>Code&#x2F;scripts</strong></h2><p>[贴代码]（感兴趣的可以通过邮箱向我要源码和过程截图）</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/blog/2023/03/20/%E9%83%A8%E7%BD%B2-%E4%BD%BF%E7%94%A8%E9%9B%86%E7%BE%A4%E7%9A%84%E7%AE%97%E5%8A%9B%E8%B7%91CPU%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1/" title="部署+使用集群的算力跑CPU密集型任务"><span class="has-text-weight-semibold">Next: 部署+使用集群的算力跑CPU密集型任务</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><a title="twitter" target="_blank" rel="noopener nofollow" href="//twitter.com//"><i class="iconfont icon-twitter"></i></a><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/SauerkrautFFish"><i class="iconfont icon-github"></i></a><!-- Ins--><a title="instagram" target="_blank" rel="noopener nofollow" href="//www.instagram.com//"><i class="iconfont icon-ins"></i></a><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--><a title="facebook" target="_blank" rel="noopener nofollow" href="//www.facebook.com//"><i class="iconfont icon-tian7_facebook"></i></a></section><p><span>Copyright ©</span><span> Jianhong Huang 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/blog/js/jquery-3.6.1.min.js"></script><script src="/blog/js/jquery-fancybox.min.js"></script><script src="/blog/js/img_zoom.js"></script><script src="/blog/js/post.js"></script></body></html>